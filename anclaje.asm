;/* This is auto-generated ASM code from LDmicro. Do not edit this file!
;   Go back to the LDmicro ladder diagram source for changes in the ladder logic. */
;Atmel AVR ATmega328 32-Pin packages is the LDmicro target processor.
.DEVICE ATmega328
;#pragma AVRPART ADMIN PART_NAME ATmega328
;.INCLUDE <m328def.inc>
.CSEG
.ORG 0x0
;TABSIZE = 8
    ; GOTO progStart
    ; WriteRuntime
          ldi 	 r30, 	 0x25	 ; (OP_LDI, ZL, FWD_LO(addr))
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, FWD_HI(addr))
          ijmp 	 		 ; (OP_IJMP, FWD(addr))
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
          reti 	 		 ; (OP_RETI)
    ; Interrupt table end.
    ; This is Reset Vector
    ; ConfigureTimerForPlcCycle
l_000025: ldi 	 r30, 	 0x80	 ; (OP_LDI, ZL, (addr & 0xff), comment) ; (REG_TCCR1A, 0x00)
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, (addr >> 8))
          ldi 	 r25, 	 0x0	 ; (OP_LDI, r25, val, lit) ; val=0 lit=0x0=0
          st  	 Z+, 	 r25	 ; (OP_ST_ZP, r25, 0, name)
          ldi 	 r30, 	 0x81	 ; (OP_LDI, ZL, (addr & 0xff), comment) ; (REG_TCCR1B, ((1 << WGM12) | plcTmr.cs) & 0xff)
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, (addr >> 8))
          ldi 	 r25, 	 0xC	 ; (OP_LDI, r25, val, lit) ; val=12 lit=0x0=0
          st  	 Z+, 	 r25	 ; (OP_ST_ZP, r25, 0, name)
          ldi 	 r30, 	 0x89	 ; (OP_LDI, ZL, (addr & 0xff), comment) ; (REG_OCR1AH, BYTE((counter >> 8) & 0xff))
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, (addr >> 8))
          ldi 	 r25, 	 0x2	 ; (OP_LDI, r25, val, lit) ; val=2 lit=0x0=0
          st  	 Z+, 	 r25	 ; (OP_ST_ZP, r25, 0, name)
          ldi 	 r30, 	 0x88	 ; (OP_LDI, ZL, (addr & 0xff), comment) ; (REG_OCR1AL, BYTE(counter & 0xff))
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, (addr >> 8))
          ldi 	 r25, 	 0x70	 ; (OP_LDI, r25, val, lit) ; val=112 lit=0x0=0
          st  	 Z+, 	 r25	 ; (OP_ST_ZP, r25, 0, name)
    ; Watchdog on
          cli 	 		 ; (OP_CLI)
          wdr 	 		 ; (OP_WDR)
          ldi 	 r25, 	 0x18	 ; (OP_LDI, r25, val)
          ldi 	 r30, 	 0x60	 ; (OP_LDI, ZL, (addr & 0xff), comment)
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, (addr >> 8))
          st  	 Z, 	 r25	 ; (OP_ST_Z, reg)
    ; - Got only four cycles to set the new values from here! -
          ldi 	 r25, 	 0x29	 ; (OP_LDI, r25, val)
          st  	 Z, 	 r25	 ; (OP_ST_Z, r25)
          sei 	 		 ; (OP_SEI)
    ; Set up the stack, which we use only when we jump to multiply/divide routine
          ldi 	 r30, 	 0x5E	 ; (OP_LDI, ZL, (addr & 0xff), comment) ; (REG_SPH, topOfMemory >> 8, topOfMemory)
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, (addr >> 8))
          ldi 	 r25, 	 0x8	 ; (OP_LDI, r25, val, lit) ; val=8 lit=0x8FF=2303
          st  	 Z+, 	 r25	 ; (OP_ST_ZP, r25, 0, name)
          ldi 	 r30, 	 0x5D	 ; (OP_LDI, ZL, (addr & 0xff), comment) ; (REG_SPL, topOfMemory & 0xff, topOfMemory)
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, (addr >> 8))
          ldi 	 r25, 	 0xFF	 ; (OP_LDI, r25, val, lit) ; val=255 lit=0x8FF=2303
          st  	 Z+, 	 r25	 ; (OP_ST_ZP, r25, 0, name)
    ; Zero out the memory used for timers, internal relays, etc.
          ldi 	 r26, 	 0x0	 ; (OP_LDI, XL, (addr & 0xff), comment)
          ldi 	 r27, 	 0x9	 ; (OP_LDI, XH, (addr >> 8))
          ldi 	 r16, 	 0x0	 ; (OP_LDI, 16, 0)
          ldi 	 r24, 	 0x0	 ; (OP_LDI, r24, (Prog.mcu()->ram[0].len) & 0xff)
          ldi 	 r25, 	 0x8	 ; (OP_LDI, r25, (Prog.mcu()->ram[0].len) >> 8)
l_00004b: st  	 -X, 	 r16	 ; (OP_ST_XS, 16)
          sbiw 	 r25:r24, 1	 ; (OP_SBIW, r24, 1)
          brne 	 l_00004b 	 ; (OP_BRNE, loopZero)
    ; Set up I/O pins
    ; Turn on the pull-ups, and drive the outputs low to start
          ldi 	 r30, 	 0x24	 ; (OP_LDI, ZL, (addr & 0xff), comment) ; (Prog.mcu()->dirRegs[i], isOutput[i])
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, (addr >> 8))
          ldi 	 r25, 	 0x4	 ; (OP_LDI, r25, val, lit) ; val=4 lit=0x0=0
          st  	 Z+, 	 r25	 ; (OP_ST_ZP, r25, 0, name)
          ldi 	 r30, 	 0x25	 ; (OP_LDI, ZL, (addr & 0xff), comment) ; (Prog.mcu()->outputRegs[i], isInput[i] & Prog.pullUpRegs[i])
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, (addr >> 8))
          ldi 	 r25, 	 0x0	 ; (OP_LDI, r25, val, lit) ; val=0 lit=0x0=0
          st  	 Z+, 	 r25	 ; (OP_ST_ZP, r25, 0, name)
          ldi 	 r30, 	 0x27	 ; (OP_LDI, ZL, (addr & 0xff), comment) ; (Prog.mcu()->dirRegs[i], isOutput[i])
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, (addr >> 8))
          ldi 	 r25, 	 0x0	 ; (OP_LDI, r25, val, lit) ; val=0 lit=0x0=0
          st  	 Z+, 	 r25	 ; (OP_ST_ZP, r25, 0, name)
          ldi 	 r30, 	 0x28	 ; (OP_LDI, ZL, (addr & 0xff), comment) ; (Prog.mcu()->outputRegs[i], isInput[i] & Prog.pullUpRegs[i])
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, (addr >> 8))
          ldi 	 r25, 	 0x0	 ; (OP_LDI, r25, val, lit) ; val=0 lit=0x0=0
          st  	 Z+, 	 r25	 ; (OP_ST_ZP, r25, 0, name)
          ldi 	 r30, 	 0x2A	 ; (OP_LDI, ZL, (addr & 0xff), comment) ; (Prog.mcu()->dirRegs[i], isOutput[i])
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, (addr >> 8))
          ldi 	 r25, 	 0x0	 ; (OP_LDI, r25, val, lit) ; val=0 lit=0x0=0
          st  	 Z+, 	 r25	 ; (OP_ST_ZP, r25, 0, name)
          ldi 	 r30, 	 0x2B	 ; (OP_LDI, ZL, (addr & 0xff), comment) ; (Prog.mcu()->outputRegs[i], isInput[i] & Prog.pullUpRegs[i])
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, (addr >> 8))
          ldi 	 r25, 	 0x14	 ; (OP_LDI, r25, val, lit) ; val=20 lit=0x0=0
          st  	 Z+, 	 r25	 ; (OP_ST_ZP, r25, 0, name)
    ; Begin Of PLC Cycle
l_000066: ldi 	 r30, 	 0x36	 ; (OP_LDI, ZL, (addr & 0xff), comment)
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, (addr >> 8))
l_000068: ld  	 r25, 	 Z	 ; (OP_LD_Z, reg)
          sbrs 	 r25, 	 1	 ; (OP_SBRS, reg, bit)
          rjmp 	 l_000068 	 ; (OP_RJMP, AvrProg.size() - std::min(skbs, uint32_t(2)))
          ldi 	 r30, 	 0x36	 ; (OP_LDI, ZL, (addr & 0xff), comment)
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, (addr >> 8))
          ld  	 r25, 	 Z	 ; (OP_LD_Z, reg, 0, name)
          sbr 	 r25, 	 0x2	 ; (OP_SBR, reg, 1 << bit)
          st  	 Z, 	 r25	 ; (OP_ST_Z, reg)
    ; Watchdog reset
          wdr 	 		 ; (OP_WDR)
    ; CompileFromIntermediate BEGIN
    ; INIT TABLES
    ; 
    ; ======= START RUNG 1 =======
    ; INT_AllocKnownAddr Rung1
    ; INT_SET_BIT $rung_top
          ldi 	 r30, 	 0x0	 ; (OP_LDI, ZL, (addr & 0xff), comment)
          ldi 	 r31, 	 0x1	 ; (OP_LDI, ZH, (addr >> 8))
          ld  	 r25, 	 Z	 ; (OP_LD_Z, reg, 0, name) ; $rung_top
          sbr 	 r25, 	 0x1	 ; (OP_SBR, reg, 1 << bit)
          st  	 Z, 	 r25	 ; (OP_ST_Z, reg)
    ; start series [
    ; start parallel [
    ; INT_CLEAR_BIT $parOut_0
          ldi 	 r30, 	 0x0	 ; (OP_LDI, ZL, (addr & 0xff), comment)
          ldi 	 r31, 	 0x1	 ; (OP_LDI, ZH, (addr >> 8))
          ld  	 r25, 	 Z	 ; (OP_LD_Z, reg, 0, name) ; $parOut_0
          cbr 	 r25, 	 0x2	 ; (OP_CBR, reg, 1 << bit)
          st  	 Z, 	 r25	 ; (OP_ST_Z, reg)
    ; INT_COPY_BIT_TO_BIT $parThis_0:=$rung_top
          ldi 	 r30, 	 0x0	 ; (OP_LDI, ZL, (addr & 0xff), comment)
          ldi 	 r31, 	 0x1	 ; (OP_LDI, ZH, (addr >> 8))
          ld  	 r25, 	 Z	 ; (OP_LD_Z, r25, 0, name2) ; $rung_top
          bst 	 r25, 	 0	 ; (OP_BST, r25, bitSrc, s) ; BIT0
          bld 	 r25, 	 2	 ; (OP_BLD, r25, bitDest, d) ; BIT2
          st  	 Z, 	 r25	 ; (OP_ST_Z, r25, 0, name1) ; $parThis_0
    ; ELEM_CONTACTS
    ; INT_IF_BIT_CLEAR XBOTON1
          ldi 	 r30, 	 0x29	 ; (OP_LDI, ZL, (addr & 0xff), comment)
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, (addr >> 8))
          ld  	 r25, 	 Z	 ; (OP_LD_Z, r25, 0, name) ; XBOTON1
          sbrc 	 r25, 	 2	 ; (OP_SBRC, r25, bit, b) ; BIT2
          rjmp 	 l_00008b 	 ; (OP_RJMP, condFalse)
    ; INT_CLEAR_BIT $parThis_0
          ldi 	 r30, 	 0x0	 ; (OP_LDI, ZL, (addr & 0xff), comment)
          ldi 	 r31, 	 0x1	 ; (OP_LDI, ZH, (addr >> 8))
          ld  	 r25, 	 Z	 ; (OP_LD_Z, reg, 0, name) ; $parThis_0
          cbr 	 r25, 	 0x4	 ; (OP_CBR, reg, 1 << bit)
          st  	 Z, 	 r25	 ; (OP_ST_Z, reg)
    ; INT_IF_BIT_SET $parThis_0
l_00008b: ldi 	 r30, 	 0x0	 ; (OP_LDI, ZL, (addr & 0xff), comment)
          ldi 	 r31, 	 0x1	 ; (OP_LDI, ZH, (addr >> 8))
          ld  	 r25, 	 Z	 ; (OP_LD_Z, reg, 0, name) ; $parThis_0
          sbrs 	 r25, 	 2	 ; (OP_SBRS, reg, bit, b) ; BIT2
          rjmp 	 l_000095 	 ; (OP_RJMP, condFalse)
    ; INT_SET_BIT $parOut_0
          ldi 	 r30, 	 0x0	 ; (OP_LDI, ZL, (addr & 0xff), comment)
          ldi 	 r31, 	 0x1	 ; (OP_LDI, ZH, (addr >> 8))
          ld  	 r25, 	 Z	 ; (OP_LD_Z, reg, 0, name) ; $parOut_0
          sbr 	 r25, 	 0x2	 ; (OP_SBR, reg, 1 << bit)
          st  	 Z, 	 r25	 ; (OP_ST_Z, reg)
    ; INT_COPY_BIT_TO_BIT $parThis_0:=$rung_top
l_000095: ldi 	 r30, 	 0x0	 ; (OP_LDI, ZL, (addr & 0xff), comment)
          ldi 	 r31, 	 0x1	 ; (OP_LDI, ZH, (addr >> 8))
          ld  	 r25, 	 Z	 ; (OP_LD_Z, r25, 0, name2) ; $rung_top
          bst 	 r25, 	 0	 ; (OP_BST, r25, bitSrc, s) ; BIT0
          bld 	 r25, 	 2	 ; (OP_BLD, r25, bitDest, d) ; BIT2
          st  	 Z, 	 r25	 ; (OP_ST_Z, r25, 0, name1) ; $parThis_0
    ; ELEM_CONTACTS
    ; INT_IF_BIT_CLEAR YLED
          ldi 	 r30, 	 0x25	 ; (OP_LDI, ZL, (addr & 0xff), comment)
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, (addr >> 8))
          ld  	 r25, 	 Z	 ; (OP_LD_Z, r25, 0, name) ; YLED
          sbrc 	 r25, 	 2	 ; (OP_SBRC, r25, bit, b) ; BIT2
          rjmp 	 l_0000a5 	 ; (OP_RJMP, condFalse)
    ; INT_CLEAR_BIT $parThis_0
          ldi 	 r30, 	 0x0	 ; (OP_LDI, ZL, (addr & 0xff), comment)
          ldi 	 r31, 	 0x1	 ; (OP_LDI, ZH, (addr >> 8))
          ld  	 r25, 	 Z	 ; (OP_LD_Z, reg, 0, name) ; $parThis_0
          cbr 	 r25, 	 0x4	 ; (OP_CBR, reg, 1 << bit)
          st  	 Z, 	 r25	 ; (OP_ST_Z, reg)
    ; INT_IF_BIT_SET $parThis_0
l_0000a5: ldi 	 r30, 	 0x0	 ; (OP_LDI, ZL, (addr & 0xff), comment)
          ldi 	 r31, 	 0x1	 ; (OP_LDI, ZH, (addr >> 8))
          ld  	 r25, 	 Z	 ; (OP_LD_Z, reg, 0, name) ; $parThis_0
          sbrs 	 r25, 	 2	 ; (OP_SBRS, reg, bit, b) ; BIT2
          rjmp 	 l_0000af 	 ; (OP_RJMP, condFalse)
    ; INT_SET_BIT $parOut_0
          ldi 	 r30, 	 0x0	 ; (OP_LDI, ZL, (addr & 0xff), comment)
          ldi 	 r31, 	 0x1	 ; (OP_LDI, ZH, (addr >> 8))
          ld  	 r25, 	 Z	 ; (OP_LD_Z, reg, 0, name) ; $parOut_0
          sbr 	 r25, 	 0x2	 ; (OP_SBR, reg, 1 << bit)
          st  	 Z, 	 r25	 ; (OP_ST_Z, reg)
    ; INT_COPY_BIT_TO_BIT $rung_top:=$parOut_0
l_0000af: ldi 	 r30, 	 0x0	 ; (OP_LDI, ZL, (addr & 0xff), comment)
          ldi 	 r31, 	 0x1	 ; (OP_LDI, ZH, (addr >> 8))
          ld  	 r25, 	 Z	 ; (OP_LD_Z, r25, 0, name2) ; $parOut_0
          bst 	 r25, 	 1	 ; (OP_BST, r25, bitSrc, s) ; BIT1
          bld 	 r25, 	 0	 ; (OP_BLD, r25, bitDest, d) ; BIT0
          st  	 Z, 	 r25	 ; (OP_ST_Z, r25, 0, name1) ; $rung_top
    ; ] finish parallel
    ; ELEM_CONTACTS
    ; INT_IF_BIT_SET XBOTON2
          ldi 	 r30, 	 0x29	 ; (OP_LDI, ZL, (addr & 0xff), comment)
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, (addr >> 8))
          ld  	 r25, 	 Z	 ; (OP_LD_Z, reg, 0, name) ; XBOTON2
          sbrs 	 r25, 	 4	 ; (OP_SBRS, reg, bit, b) ; BIT4
          rjmp 	 l_0000bf 	 ; (OP_RJMP, condFalse)
    ; INT_CLEAR_BIT $rung_top
          ldi 	 r30, 	 0x0	 ; (OP_LDI, ZL, (addr & 0xff), comment)
          ldi 	 r31, 	 0x1	 ; (OP_LDI, ZH, (addr >> 8))
          ld  	 r25, 	 Z	 ; (OP_LD_Z, reg, 0, name) ; $rung_top
          cbr 	 r25, 	 0x1	 ; (OP_CBR, reg, 1 << bit)
          st  	 Z, 	 r25	 ; (OP_ST_Z, reg)
    ; ELEM_COIL
    ; INT_COPY_BIT_TO_BIT YLED:=$rung_top
l_0000bf: ldi 	 r30, 	 0x0	 ; (OP_LDI, ZL, (addr & 0xff), comment)
          ldi 	 r31, 	 0x1	 ; (OP_LDI, ZH, (addr >> 8))
          ld  	 r25, 	 Z	 ; (OP_LD_Z, r25, 0, name2) ; $rung_top
          bst 	 r25, 	 0	 ; (OP_BST, r25, bitSrc, s) ; BIT0
          ldi 	 r30, 	 0x25	 ; (OP_LDI, ZL, (addr & 0xff), comment)
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, (addr >> 8))
          ld  	 r25, 	 Z	 ; (OP_LD_Z, r25)
          bld 	 r25, 	 2	 ; (OP_BLD, r25, bitDest, d) ; BIT2
          st  	 Z, 	 r25	 ; (OP_ST_Z, r25, 0, name1) ; YLED
    ; ] finish series
    ; INT_AllocKnownAddr Rung2
    ; Latest INT_OP here
    ; CompileFromIntermediate END
    ; GOTO next PLC cycle
          ldi 	 r30, 	 0x66	 ; (OP_LDI, ZL, addr & 0xff)
          ldi 	 r31, 	 0x0	 ; (OP_LDI, ZH, (addr >> 8) & 0xff)
          ijmp 	 		 ; (OP_IJMP, addr)
l_0000cb: rjmp 	 l_0000cb 	 ; (OP_RJMP, AvrProg.size())

;|  # | Name                                                    | Size      | Address      | Bit # |
;|Variables: 7

;|Internal Relays: 3
;|  0 | $rung_top                                         	|   1 bit   | 0x0100       | 0     |
;|  1 | $parOut_0                                         	|   1 bit   | 0x0100       | 1     |
;|  2 | $parThis_0                                        	|   1 bit   | 0x0100       | 2     |

